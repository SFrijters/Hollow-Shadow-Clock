// Hollow Shadow Clock by DIY Machines based on Shiura's Hollow Clock
// Projects instructional video: https://youtu.be/KYB3sjW5J2g
// Written build guide including links to electronics parts, 3D printing files and wiring diagrams: https://www.diymachines.co.uk
// The LED is set not to be brighter then 75% of it's max output. This is to help reduce heat generated by the LED. It is not recommended to override this or hinder the desings ability to cool the LED in any way.
// Disclaimer: DIY projects are purely "at your own risk". Unfamiliarity with tools and processes can be dangerous. DIY Machines Ltd will not be held responsible for any injury due to the misues or misunderstanding of any DIY project.

#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <Adafruit_NeoPixel.h>
#include <time.h>
#include <vector>
#include <ArduinoJson.h> // Include ArduinoJson library

// Replace with your network credentials
const char* ssid = "YOUR-WIFI-NAME-HERE";
const char* password = "YOUR-WIFI-PASSWORD-HERE";

// Debounce delay for buttons (milliseconds)
const unsigned long debounceDelay = 50; // Adjust this value as needed

ESP8266WebServer server(80);

// Schedule entry structure
struct ScheduleEntry {
  String name;
  int startHour;
  int startMinute;
  int stopHour;
  int stopMinute;
  int brightness;
  int red;
  int green;
  int blue;
  bool daysOfWeek[7]; // 0 = Sunday, 6 = Saturday
};

std::vector<ScheduleEntry> scheduleEntries;

// NeoPixel setup
#define PIN D4
#define NUMPIXELS 1
Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); // Note: NEO_GRB indicates color order

// Stepper motor control variables
#define STEPS_PER_ROTATION 15360 // steps for a full turn of minute rotor
int delaytime = 4;
int port[4] = {5, 4, 14, 12};
int seq[4][4] = {
  {  LOW,  LOW, HIGH,  LOW},
  {  LOW,  LOW,  LOW, HIGH},
  { HIGH,  LOW,  LOW,  LOW},
  {  LOW, HIGH,  LOW,  LOW}
};

// NTP server details
const char* ntpServer = "pool.ntp.org";
long  gmtOffset_sec = 0;  // Changed from const to allow modification
int   daylightOffset_sec = 0; // Changed from const to allow modification

// Manual override variables
bool manualOverrideActive = false;
uint32_t manualColor = pixels.Color(0, 0, 0); // Default color
int manualBrightness = 128; // Default brightness (0-255)
int manualOverrideResetTime = -1; // Time in minutes when manual override should reset (-1 means no reset scheduled)

// Button states
const int buttonColorPin = 13;
const int buttonBrightnessPin = 0;
int colorState = 0; // 0: Red, 1: Green, 2: Blue, 3: White
int brightnessState = 0; // 0: 15%, 1: 40%, 2: 60%, 3: 75%, 4: 0%

bool getLocalTime(struct tm * info, uint32_t ms = 5000) {
  uint32_t start = millis();
  time_t now;
  while ((millis() - start) <= ms) {
    time(&now);
    localtime_r(&now, info);
    if (info->tm_year > (1970 - 1900)) {
      return true;
    }
    delay(10);
  }
  return false;
}

void rotate(int step) {
  static int phase = 0;
  int i, j;
  int delta = (step > 0) ? 1 : 3;
  int dt = 20;

  step = (step > 0) ? step : -step;
  for (j = 0; j < step; j++) {
    phase = (phase + delta) % 4;
    for (i = 0; i < 4; i++) {
      digitalWrite(port[i], seq[phase][i]);
    }
    delay(dt);
    if (dt > delaytime) dt--;
  }
  // power cut
  for (i = 0; i < 4; i++) {
    digitalWrite(port[i], LOW);
  }
}

void handleRoot() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain time");
  }
  String html = "<html><head>";
  html += "<title>Hollow Shadow Clock by DIY Machines</title>";
  html += "<style>";
  html += "body { font-family: Arial, sans-serif; background-color: #f0f0f0; margin: 0; padding: 0; }";
  html += ".container { max-width: 800px; margin: auto; background: #ffffff; padding: 20px; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1); border-radius: 10px; margin-top: 50px; }";
  html += "h1, h2 { text-align: center; color: #333333; }";
  html += "form { display: flex; flex-direction: column; gap: 10px; }";
  html += "input[type=text], input[type=number], input[type=submit], input[type=time], input[type=range], select { padding: 10px; border: 1px solid #dddddd; border-radius: 5px; }";
  html += "input[type=checkbox] { margin-right: 5px; }";
  html += "input[type=submit] { background-color: #4CAF50; color: white; border: none; cursor: pointer; font-weight: bold; }";
  html += "input[type=submit]:hover { background-color: #45a049; }";
  html += "p { color: #555555; }";
  html += ".schedule-entry { border: 1px solid #dddddd; padding: 15px; margin-bottom: 15px; border-radius: 10px; box-shadow: 0px 0px 5px rgba(0,0,0,0.1); }";
  html += ".schedule-entry h3 { margin-top: 0; }";
  html += ".schedule-entry .color-preview { width: 30px; height: 30px; border-radius: 5px; margin-left: auto; }";
  html += ".schedule-entry .entry-row { display: flex; align-items: center; }";
  html += ".schedule-entry .entry-row p { margin: 0; }";
  html += "a { color: #1E90FF; text-decoration: none; }";
  html += "a:hover { text-decoration: underline; }";
  html += ".days-of-week { display: flex; flex-wrap: wrap; gap: 10px; }";
  html += ".days-of-week label { display: flex; align-items: center; }";
  html += ".rgb-sliders { display: flex; gap: 10px; align-items: center; }";
  html += ".rgb-sliders label { display: flex; flex-direction: column; align-items: center; flex: 1; }";
  html += ".rgb-sliders input[type=range]::-webkit-slider-thumb { width: 20px; height: 20px; border-radius: 50%; background: currentColor; }";
  html += ".time-inputs { display: flex; gap: 20px; }";
  html += ".time-inputs label { flex: 1; }";
  html += ".info-box { max-width: 800px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 10px; box-shadow: 0px 0px 5px rgba(0,0,0,0.1); }";
  html += ".info-box p { margin: 10px 0; text-align: center; }";
  html += ".info-box a { color: #1E90FF; text-decoration: none; }";
  html += ".info-box a:hover { text-decoration: underline; }";
  html += ".add-schedule-btn { background-color: #4CAF50; color: white; border: none; padding: 10px; cursor: pointer; font-size: 16px; font-weight: bold; }";
  html += ".add-schedule-btn:hover { background-color: #45a049; }";
  html += ".manual-override-banner { background-color: yellow; color: black; padding: 10px; text-align: center; font-weight: bold; display: none; }";
  html += "</style></head><body>";

  // Banner placeholder (now managed by JavaScript)
  html += "<div id='manualOverrideBanner' class='manual-override-banner'>";
  html += "LED brightness and colour is currently under manual control from the push buttons. A scheduled scene will override this.";
  html += "</div>";

  // Main container with scheduler
  html += "<div class='container'>";

  // Updated heading with 'Projection Scheduler' on a new line
  html += "<h1>Hollow Shadow Clock</h1><h2>Projection Scheduler</h2>";

  // Display Current Time with Date and Timezone
  html += "<div style='display: flex; align-items: center; justify-content: center; margin-bottom: 20px;'>";
  html += "<b>Current Time: &nbsp;</b><span id='time'></span>";
  html += "</div>";

  // Timezone Selection Form
  html += "<form action='/setTimezone' method='POST' style='display: flex; align-items: center; justify-content: center; margin-bottom: 20px;'>";
  html += "<label for='timezone'>Select Timezone:&nbsp;</label>";
  html += "<select name='timezone' id='timezone'>";

  // Timezone options
  int currentOffsetHours = gmtOffset_sec / 3600;
  struct TimezoneOption {
    const char* name;
    int offset;
  };
  TimezoneOption timezones[] = {
    {"GMT-12:00", -12},
    {"GMT-11:00", -11},
    {"GMT-10:00", -10},
    {"GMT-9:00", -9},
    {"GMT-8:00", -8},
    {"GMT-7:00", -7},
    {"GMT-6:00", -6},
    {"GMT-5:00", -5},
    {"GMT-4:00", -4},
    {"GMT-3:00", -3},
    {"GMT-2:00", -2},
    {"GMT-1:00", -1},
    {"GMT+0:00", 0},
    {"GMT+1:00", 1},
    {"GMT+2:00", 2},
    {"GMT+3:00", 3},
    {"GMT+4:00", 4},
    {"GMT+5:00", 5},
    {"GMT+6:00", 6},
    {"GMT+7:00", 7},
    {"GMT+8:00", 8},
    {"GMT+9:00", 9},
    {"GMT+10:00", 10},
    {"GMT+11:00", 11},
    {"GMT+12:00", 12},
    {"GMT+13:00", 13},
    {"GMT+14:00", 14}
  };
  for (int i = 0; i < sizeof(timezones) / sizeof(TimezoneOption); i++) {
    html += "<option value='";
    html += String(timezones[i].offset);
    html += "'";
    if (timezones[i].offset == currentOffsetHours) {
      html += " selected";
    }
    html += ">";
    html += timezones[i].name;
    html += "</option>";
  }
  html += "</select>";
  html += "&nbsp;<input type='submit' value='Set Timezone'>";
  html += "</form>";

  html += "<form action=\"/addSchedule\" method=\"POST\">";
  html += "Schedule Name: <input type=\"text\" name=\"name\"><br>";

  // Start and Stop Time on the same row
  html += "<div class=\"time-inputs\">";
  html += "<label>Start Time: <input type=\"time\" name=\"startTime\"></label>";
  html += "<label>Stop Time: <input type=\"time\" name=\"stopTime\"></label>";
  html += "</div><br>";

  // RGB and Brightness sliders
  html += "<div class=\"rgb-sliders\">";
  html += "<label style=\"color: red;\">Red:<input type=\"range\" name=\"red\" min=\"0\" max=\"255\" value=\"0\" id=\"redSlider\"></label>";
  html += "<label style=\"color: green;\">Green:<input type=\"range\" name=\"green\" min=\"0\" max=\"255\" value=\"0\" id=\"greenSlider\"></label>";
  html += "<label style=\"color: blue;\">Blue:<input type=\"range\" name=\"blue\" min=\"0\" max=\"255\" value=\"0\" id=\"blueSlider\"></label>";
  html += "<label>Brightness:<input type=\"range\" name=\"brightness\" min=\"0\" max=\"255\" value=\"128\" id=\"brightnessSlider\"></label>";
  html += "</div>";
  html += "<div style=\"display: flex; align-items: center; margin-top: 10px;\">";
  html += "<div id=\"colorPreview\" style=\"width:30px; height:30px; background-color: rgb(0,0,0); border-radius:5px; border: 1px solid #ccc;\"></div>";
  html += "</div><br>";

  // Days of the week
  html += "<b>Which days of the week should this apply?</b><br>";
  html += "<div class=\"days-of-week\">";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"0\"> Sunday</label>";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"1\"> Monday</label>";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"2\"> Tuesday</label>";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"3\"> Wednesday</label>";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"4\"> Thursday</label>";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"5\"> Friday</label>";
  html += "<label><input type=\"checkbox\" name=\"day\" value=\"6\"> Saturday</label>";
  html += "</div><br>";

  html += "<button type=\"submit\" class=\"add-schedule-btn\">+ Add Schedule</button>";
  html += "</form>";
  html += "</div>"; // Close container

  // Current Schedules Section
  html += "<div class='container' style='margin-top: 20px;'>";
  html += "<h2>Current Schedules</h2>";
  for (size_t i = 0; i < scheduleEntries.size(); i++) {
    html += "<div class=\"schedule-entry\">";
    html += "<h3>" + scheduleEntries[i].name + "</h3>";
    html += "<div class=\"entry-row\">";
    String start = String(scheduleEntries[i].startHour) + ":" + (scheduleEntries[i].startMinute < 10 ? "0" : "") + String(scheduleEntries[i].startMinute);
    String stop = String(scheduleEntries[i].stopHour) + ":" + (scheduleEntries[i].stopMinute < 10 ? "0" : "") + String(scheduleEntries[i].stopMinute);
    // Display days of the week
    String days = "";
    const char* dayNames[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    for (int j = 0; j < 7; j++) {
      if (scheduleEntries[i].daysOfWeek[j]) {
        if (days.length() > 0) days += ", ";
        days += dayNames[j];
      }
    }
    html += "<p>Start: " + start + ", Stop: " + stop + ", Days: " + days + "</p>";
    html += "</div>";
    html += "<div class=\"entry-row\">";
    // Calculate brightness percentage
    int brightnessPercent = (scheduleEntries[i].brightness * 100) / 255;
    html += "<p>Brightness: " + String(brightnessPercent) + "%, RGB: (" + String(scheduleEntries[i].red) + ", " + String(scheduleEntries[i].green) + ", " + String(scheduleEntries[i].blue) + ")</p>";
    // Color preview
    html += "<div class=\"color-preview\" style=\"background-color: rgb(" + String(scheduleEntries[i].red) + "," + String(scheduleEntries[i].green) + "," + String(scheduleEntries[i].blue) + ");\"></div>";
    html += "</div>";
    html += "<p><a href=\"/removeSchedule?index=" + String(i) + "\">Remove</a></p>";
    html += "</div>";
  }
  html += "</div>"; // Close container

  // Links to your website, YouTube channel, Patreon page, and Shiura's page
  html += "<div class='info-box'>";
  html += "<p><a href='https://diymachines.co.uk' target='_blank'>DIY Machines Website</a></p>";
  html += "<p><a href='https://youtube.com/diymachines' target='_blank'>DIY Machines YouTube Channel</a></p>";
  html += "<p><a href='http://patreon.com/diymachines/membership' target='_blank'>Support DIY Machines on Patreon</a></p>";
  html += "<p>This design is a remix with Shiura's kind permission. <a href='https://www.thingiverse.com/thing:5636482' target='_blank'>Original Design by Shiura</a></p>";
  html += "</div>";

  // JavaScript for color preview and time display
  html += "<script>";
  html += "function updateColorPreview() {";
  html += "  var r = document.getElementById('redSlider').value;";
  html += "  var g = document.getElementById('greenSlider').value;";
  html += "  var b = document.getElementById('blueSlider').value;";
  html += "  var brightness = document.getElementById('brightnessSlider').value;";
  html += "  document.getElementById('colorPreview').style.backgroundColor = 'rgb(' + r + ',' + g + ',' + b + ')';";
  html += "}";
  html += "document.getElementById('redSlider').addEventListener('input', updateColorPreview);";
  html += "document.getElementById('greenSlider').addEventListener('input', updateColorPreview);";
  html += "document.getElementById('blueSlider').addEventListener('input', updateColorPreview);";
  html += "document.getElementById('brightnessSlider').addEventListener('input', updateColorPreview);";
  html += "updateColorPreview();";

  // JavaScript for updating time display
  html += "function updateTime() {";
  html += "  var now = new Date();";
  html += "  var timezoneOffset = " + String(gmtOffset_sec / 3600) + ";"; // in hours
  html += "  var utc = now.getTime() + (now.getTimezoneOffset() * 60000);";
  html += "  var adjustedTime = new Date(utc + (3600000 * timezoneOffset));";
  html += "  var options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',";
  html += "                  hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };";
  html += "  var formattedTime = adjustedTime.toLocaleString('en-GB', options);";
  html += "  document.getElementById('time').innerText = formattedTime + ' (GMT' + (timezoneOffset >= 0 ? '+' : '') + timezoneOffset + ')';";
  html += "}";
  html += "setInterval(updateTime, 1000);";
  html += "updateTime();";

  // JavaScript for checking manual override status
  html += "function checkManualOverride() {";
  html += "  fetch('/manualOverrideStatus').then(function(response) {";
  html += "    return response.json();";
  html += "  }).then(function(data) {";
  html += "    var banner = document.getElementById('manualOverrideBanner');";
  html += "    if (data.manualOverrideActive) {";
  html += "      banner.style.display = 'block';";
  html += "    } else {";
  html += "      banner.style.display = 'none';";
  html += "    }";
  html += "  });";
  html += "}";
  html += "setInterval(checkManualOverride, 1000);";
  html += "checkManualOverride();";
  html += "</script>";

  html += "</body></html>";
  server.send(200, "text/html", html);
}

void handleManualOverrideStatus() {
  StaticJsonDocument<200> jsonDoc;
  jsonDoc["manualOverrideActive"] = manualOverrideActive;
  String jsonResponse;
  serializeJson(jsonDoc, jsonResponse);
  server.send(200, "application/json", jsonResponse);
}

void handleSetTimezone() {
  if (server.hasArg("timezone")) {
    String timezoneStr = server.arg("timezone");
    long timezoneOffset = timezoneStr.toInt() * 3600; // Convert hours to seconds
    gmtOffset_sec = timezoneOffset;

    // Reconfigure time
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

    // Optional: Print new local time
    printLocalTime();

    // Redirect back to root
    server.sendHeader("Location", "/");
    server.send(303);
  } else {
    server.send(400, "text/plain", "Timezone not specified");
  }
}

void handleAddSchedule() {
  ScheduleEntry newEntry;
  if (server.hasArg("name")) {
    newEntry.name = server.arg("name");
  }
  if (server.hasArg("startTime")) {
    sscanf(server.arg("startTime").c_str(), "%d:%d", &newEntry.startHour, &newEntry.startMinute);
  }
  if (server.hasArg("stopTime")) {
    sscanf(server.arg("stopTime").c_str(), "%d:%d", &newEntry.stopHour, &newEntry.stopMinute);
  }
  if (server.hasArg("brightness")) {
    newEntry.brightness = server.arg("brightness").toInt();
  }
  if (server.hasArg("red")) {
    newEntry.red = server.arg("red").toInt();
  }
  if (server.hasArg("green")) {
    newEntry.green = server.arg("green").toInt();
  }
  if (server.hasArg("blue")) {
    newEntry.blue = server.arg("blue").toInt();
  }

  // Initialize daysOfWeek to false
  for (int i = 0; i < 7; i++) {
    newEntry.daysOfWeek[i] = false;
  }

  // Collect all "day" arguments
  for (int i = 0; i < server.args(); i++) {
    if (server.argName(i) == "day") {
      int dayIndex = server.arg(i).toInt();
      if (dayIndex >= 0 && dayIndex <= 6) {
        newEntry.daysOfWeek[dayIndex] = true;
      }
    }
  }

  scheduleEntries.push_back(newEntry);
  server.sendHeader("Location", "/");
  server.send(303);
}

void handleRemoveSchedule() {
  if (server.hasArg("index")) {
    int index = server.arg("index").toInt();
    if (index >= 0 && index < scheduleEntries.size()) {
      scheduleEntries.erase(scheduleEntries.begin() + index);
    }
  }
  server.sendHeader("Location", "/");
  server.send(303);
}

void updateLED() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return;
  }

  int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;

  // Check if manual override should be reset
  if (manualOverrideActive && manualOverrideResetTime != -1 && currentMinutes >= manualOverrideResetTime) {
    manualOverrideActive = false;
    manualOverrideResetTime = -1; // Reset the override reset time
  }

  if (manualOverrideActive) {
    // Apply manual override
    pixels.clear();
    pixels.setPixelColor(0, manualColor);
    pixels.setBrightness(manualBrightness);
    pixels.show();
    return;
  }

  // Check for active scheduled scenes
  bool scheduleActive = false;
  for (const auto& entry : scheduleEntries) {
    bool activeDay = entry.daysOfWeek[timeinfo.tm_wday];
    int scheduleStartMinutes = entry.startHour * 60 + entry.startMinute;
    int scheduleStopMinutes = entry.stopHour * 60 + entry.stopMinute;
    bool withinTime = (currentMinutes >= scheduleStartMinutes) && (currentMinutes < scheduleStopMinutes);

    if (activeDay && withinTime) {
      scheduleActive = true;
      pixels.clear();
      // Swap red and green values here
      pixels.setPixelColor(0, pixels.Color(entry.green, entry.red, entry.blue));
      pixels.setBrightness(entry.brightness);
      pixels.show();
      return;
    }
  }

  // No schedule active
  pixels.clear();
  pixels.show();
}

void printLocalTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain time");
    return;
  }
  char timeStringBuff[64];
  strftime(timeStringBuff, sizeof(timeStringBuff), "%A, %B %d %Y %H:%M:%S", &timeinfo);
  Serial.println(timeStringBuff);
}

void setup() {
  Serial.begin(115200);

  // Initialize NeoPixel
  pixels.begin();

  // Setup button pins
  pinMode(buttonColorPin, INPUT_PULLUP);
  pinMode(buttonBrightnessPin, INPUT_PULLUP);

  // Connect to Wi-Fi with a timeout
  WiFi.begin(ssid, password);
  int maxAttempts = 10; // Maximum number of attempts
  int attempt = 0;
  while (WiFi.status() != WL_CONNECTED && attempt < maxAttempts) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
    attempt++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Connected to WiFi");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());

    // Configure time
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    printLocalTime();

    // Start the server
    server.on("/", handleRoot);
    server.on("/addSchedule", HTTP_POST, handleAddSchedule);
    server.on("/removeSchedule", handleRemoveSchedule);
    server.on("/setTimezone", HTTP_POST, handleSetTimezone);
    server.on("/manualOverrideStatus", handleManualOverrideStatus); // New endpoint
    server.begin();
    Serial.println("HTTP server started");
  } else {
    Serial.println("Failed to connect to WiFi. Proceeding without Wi-Fi.");
  }

  // Setup stepper motor pins
  pinMode(port[0], OUTPUT);
  pinMode(port[1], OUTPUT);
  pinMode(port[2], OUTPUT);
  pinMode(port[3], OUTPUT);
  rotate(-10); // for approach run
  rotate(10);  // approach run without heavy load
  rotate(STEPS_PER_ROTATION / 60);
}

void updateClock() {
  static long prev_min = 0, prev_pos = 0;
  long min;
  static long pos;

  min = millis() / 4000; // Adjust as needed for accurate timekeeping - Standard - 60000
  if (prev_min == min) {
    return;
  }
  prev_min = min;
  pos = (STEPS_PER_ROTATION * min) / 60;
  rotate(-10); // for approach run
  rotate(10); // approach run without heavy load
  if (pos - prev_pos > 0) {
    rotate(pos - prev_pos);
  }
  prev_pos = pos;
}

void readButtons() {
  static unsigned long lastDebounceTimeColor = 0;
  static unsigned long lastDebounceTimeBrightness = 0;
  static int lastButtonColorState = HIGH;
  static int lastButtonBrightnessState = HIGH;
  //const unsigned long debounceDelay = 50;

  int readingColor = digitalRead(buttonColorPin);
  if (readingColor != lastButtonColorState) {
    lastDebounceTimeColor = millis();
  }
  if ((millis() - lastDebounceTimeColor) > debounceDelay) {
    if (readingColor == LOW) {
      // Button pressed, cycle color
      colorState = (colorState + 1) % 4;
      manualOverrideActive = true;
      switch (colorState) {
        case 0: manualColor = pixels.Color(255, 0, 0); break; // Red
        case 1: manualColor = pixels.Color(0, 255, 0); break; // Green
        case 2: manualColor = pixels.Color(0, 0, 255); break; // Blue
        case 3: manualColor = pixels.Color(255, 255, 255); break; // White
      }
      // Determine when the manual override should reset
      setManualOverrideResetTime();
    }
  }
  lastButtonColorState = readingColor;

  int readingBrightness = digitalRead(buttonBrightnessPin);
  if (readingBrightness != lastButtonBrightnessState) {
    lastDebounceTimeBrightness = millis();
  }
  if ((millis() - lastDebounceTimeBrightness) > debounceDelay) {
    if (readingBrightness == LOW) {
      // Button pressed, cycle brightness
      brightnessState = (brightnessState + 1) % 5;
      manualOverrideActive = true;
      switch (brightnessState) {
        case 0: manualBrightness = (255 * 15) / 100; break; // 15%
        case 1: manualBrightness = (255 * 40) / 100; break; // 40%
        case 2: manualBrightness = (255 * 60) / 100; break; // 60%
        case 3: manualBrightness = (255 * 75) / 100; break; // 75%
        case 4: manualBrightness = 0; break;                // 0%
      }
      // Determine when the manual override should reset
      setManualOverrideResetTime();
    }
  }
  lastButtonBrightnessState = readingBrightness;
}

void setManualOverrideResetTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return;
  }
  int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;
  int earliestStartTime = -1;

  for (const auto& entry : scheduleEntries) {
    if (entry.daysOfWeek[timeinfo.tm_wday]) {
      int scheduleStartMinutes = entry.startHour * 60 + entry.startMinute;
      if (scheduleStartMinutes <= currentMinutes) {
        // Skip past schedules
        continue;
      }
      if (earliestStartTime == -1 || scheduleStartMinutes < earliestStartTime) {
        earliestStartTime = scheduleStartMinutes;
      }
    }
  }

  if (earliestStartTime != -1) {
    manualOverrideResetTime = earliestStartTime;
  } else {
    // No upcoming schedules today, set reset time to midnight
    manualOverrideResetTime = 24 * 60; // Minutes in a day
  }
}

void loop() {
  updateClock();
  readButtons();
  if (WiFi.status() == WL_CONNECTED) {
    server.handleClient();
    updateLED();
  }
}
